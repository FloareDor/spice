r"""
spice database integration validator
Verifies end-to-end embedding storage and retrieval.

Usage:
    python validate_lancedb.py

Activate venv first:
    .\venv\Scripts\activate
"""
import shutil
import subprocess
import sys
from pathlib import Path

import numpy as np
import soundfile as sf

# Import our database module
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))
from spice import database as db


def generate_test_audio(filename: str = "test_audio.wav", duration: float = 5.0) -> str:
    """Generates a simple sine wave audio file for testing."""
    sr = 22050
    t = np.linspace(0, duration, int(sr * duration))
    y = 0.5 * np.sin(2 * np.pi * 440 * t)  # 440Hz A4
    sf.write(filename, y, sr)
    print(f"   Generated test audio: {filename}")
    return filename


def extract_clamp_embedding(audio_path: Path, output_dir: Path) -> np.ndarray:
    """
    Run CLaMP 3 to extract embedding from audio file.

    Returns:
        768-dimensional embedding array.
    """
    clamp_script = Path("clamp3/clamp3_embd.py").resolve()

    if not clamp_script.exists():
        raise FileNotFoundError(f"CLaMP 3 script not found at {clamp_script}")

    # CLaMP expects directories, not single files
    # Use unique temp names to avoid conflicts with CLaMP's internal 'temp' folder
    import uuid
    unique_id = uuid.uuid4().hex[:8]

    temp_input = output_dir / f"clamp_in_{unique_id}"
    temp_input.mkdir(exist_ok=True)

    temp_audio = temp_input / audio_path.name
    shutil.copy(audio_path, temp_audio)

    temp_output = output_dir / f"clamp_out_{unique_id}"
    # Ensure output dir does NOT exist - CLaMP checks and skips if it does
    if temp_output.exists():
        shutil.rmtree(temp_output)
    # DO NOT create temp_output - CLaMP will create it and skips if it exists

    cmd = [
        sys.executable,
        str(clamp_script),
        str(temp_input.resolve()),
        str(temp_output.resolve()),
        "--get_global"
    ]

    # Run from clamp3 directory so imports work
    result = subprocess.run(
        cmd,
        cwd=str(clamp_script.parent),
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"   CLaMP stdout: {result.stdout}")
        print(f"   CLaMP stderr: {result.stderr}")
        raise RuntimeError(f"CLaMP extraction failed: {result.returncode}")

    # Find the output .npy file
    npy_files = list(temp_output.rglob("*.npy"))
    if not npy_files:
        # Debug: show what files were created
        all_files = list(temp_output.rglob("*"))
        print(f"   Files in output dir: {all_files}")
        print(f"   CLaMP stdout: {result.stdout[:500] if result.stdout else 'empty'}")
        print(f"   CLaMP stderr: {result.stderr[:500] if result.stderr else 'empty'}")
        raise FileNotFoundError("No embedding file generated by CLaMP 3")

    # Load embedding
    embedding = np.load(npy_files[0])

    # CLaMP may output (1, 768) or (768,) - flatten if needed
    if embedding.ndim > 1:
        embedding = embedding.flatten()

    # Cleanup temp dirs
    shutil.rmtree(temp_input, ignore_errors=True)
    shutil.rmtree(temp_output, ignore_errors=True)

    return embedding


def main():
    print()
    print("=" * 60)
    print("  spice database integration validator")
    print("=" * 60)
    print()

    base_dir = Path.cwd()
    test_dir = base_dir / "test_lancedb"
    db_path = base_dir / "test_spice.lance"

    # Cleanup from previous runs
    if test_dir.exists():
        shutil.rmtree(test_dir, ignore_errors=True)
    if db_path.exists():
        shutil.rmtree(db_path, ignore_errors=True)

    test_dir.mkdir(exist_ok=True)

    success = True

    try:
        # Step 1: Generate test audio
        print("[1/5] Generating test audio...")
        audio_path = test_dir / "test_sine.wav"
        generate_test_audio(str(audio_path))
        print("   OK")
        print()

        # Step 2: Extract embedding via CLaMP 3
        print("[2/5] Extracting CLaMP 3 embedding...")
        embedding = extract_clamp_embedding(audio_path, test_dir)
        print(f"   Embedding shape: {embedding.shape}")
        print(f"   Embedding dtype: {embedding.dtype}")
        print(f"   Embedding range: [{embedding.min():.4f}, {embedding.max():.4f}]")
        print("   OK")
        print()

        # Step 3: Store in LanceDB
        print("[3/5] Storing embedding in LanceDB...")
        lance_db = db.get_db(str(db_path))
        table = db.create_samples_table(lance_db)

        metadata = db.build_metadata(
            filename="test_sine.wav",
            path=str(audio_path.resolve()),
            bpm=120.0,  # Simulated
            key="A major",  # 440Hz is A
            duration_sec=5.0,
            file_size_bytes=audio_path.stat().st_size,
        )

        db.add_sample(table, "test_sine.wav", embedding, metadata)
        count = db.count_samples(table)
        print(f"   Samples in DB: {count}")
        print("   OK")
        print()

        # Step 4: Self-similarity search
        print("[4/5] Testing self-similarity search...")
        results = db.search_by_embedding(table, embedding, limit=5)

        if not results:
            print("   FAIL: No results returned!")
            success = False
        else:
            top_match = results[0]
            print(f"   Top match: {top_match['filename']}")
            print(f"   Distance:  {top_match['_distance']:.6f}")

            if top_match['filename'] == "test_sine.wav":
                print("   Self-match confirmed!")
                if top_match['_distance'] < 0.001:
                    print("   Distance ~0 as expected")
                else:
                    print(f"   WARNING: Distance higher than expected: {top_match['_distance']}")
            else:
                print("   FAIL: Top match is not the query file!")
                success = False
        print("   OK")
        print()

        # Step 5: Verify retrieval
        print("[5/5] Testing direct retrieval...")
        retrieved = db.get_sample(table, "test_sine.wav")

        if retrieved is None:
            print("   FAIL: Could not retrieve sample!")
            success = False
        else:
            print(f"   Retrieved: {retrieved['filename']}")
            print(f"   Metadata keys: {list(retrieved['metadata'].keys())}")
            print(f"   BPM: {retrieved['metadata']['bpm']}")
            print(f"   Key: {retrieved['metadata']['key']}")

            # Verify embedding matches
            if np.allclose(retrieved['embedding'], embedding):
                print("   Embedding integrity verified")
            else:
                print("   WARNING: Retrieved embedding differs from original!")
        print("   OK")
        print()

        # Verify database file was created
        print("=" * 60)
        if db_path.exists():
            print(f"  Database created at: {db_path}")
        else:
            print("  WARNING: Database path not found!")
            success = False

    except Exception as e:
        print(f"   ERROR: {e}")
        import traceback
        traceback.print_exc()
        success = False

    finally:
        # Cleanup
        print()
        print("Cleaning up test files...")
        shutil.rmtree(test_dir, ignore_errors=True)
        shutil.rmtree(db_path, ignore_errors=True)

    print()
    print("=" * 60)
    if success:
        print("  LanceDB integration validated successfully!")
        print("  Next step: Implement full indexer with batch processing")
    else:
        print("  Validation FAILED. Check errors above.")
    print("=" * 60)
    print()

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
